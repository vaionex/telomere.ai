import{R as w,i,C as R}from"./BDPGcIsz.js";var c;(function(n){n[n.Audio=1]="Audio",n[n.Cache=2]="Cache",n[n.Config=3]="Config",n[n.Data=4]="Data",n[n.LocalData=5]="LocalData",n[n.Document=6]="Document",n[n.Download=7]="Download",n[n.Picture=8]="Picture",n[n.Public=9]="Public",n[n.Video=10]="Video",n[n.Resource=11]="Resource",n[n.Temp=12]="Temp",n[n.AppConfig=13]="AppConfig",n[n.AppData=14]="AppData",n[n.AppLocalData=15]="AppLocalData",n[n.AppCache=16]="AppCache",n[n.AppLog=17]="AppLog",n[n.Desktop=18]="Desktop",n[n.Executable=19]="Executable",n[n.Font=20]="Font",n[n.Home=21]="Home",n[n.Runtime=22]="Runtime",n[n.Template=23]="Template"})(c||(c={}));var u;(function(n){n[n.Start=0]="Start",n[n.Current=1]="Current",n[n.End=2]="End"})(u||(u={}));function l(n){return{isFile:n.isFile,isDirectory:n.isDirectory,isSymlink:n.isSymlink,size:n.size,mtime:n.mtime!==null?new Date(n.mtime):null,atime:n.atime!==null?new Date(n.atime):null,birthtime:n.birthtime!==null?new Date(n.birthtime):null,readonly:n.readonly,fileAttributes:n.fileAttributes,dev:n.dev,ino:n.ino,mode:n.mode,nlink:n.nlink,uid:n.uid,gid:n.gid,rdev:n.rdev,blksize:n.blksize,blocks:n.blocks}}function U(n){const e=new Uint8ClampedArray(n),t=e.byteLength;let o=0;for(let r=0;r<t;r++){const s=e[r];o*=256,o+=s}return o}class d extends w{async read(e){if(e.byteLength===0)return 0;const t=await i("plugin:fs|read",{rid:this.rid,len:e.byteLength}),o=U(t.slice(-8)),r=t instanceof ArrayBuffer?new Uint8Array(t):t;return e.set(r.slice(0,r.length-8)),o===0?null:o}async seek(e,t){return await i("plugin:fs|seek",{rid:this.rid,offset:e,whence:t})}async stat(){const e=await i("plugin:fs|fstat",{rid:this.rid});return l(e)}async truncate(e){await i("plugin:fs|ftruncate",{rid:this.rid,len:e})}async write(e){return await i("plugin:fs|write",{rid:this.rid,data:e})}}async function b(n,e){if(n instanceof URL&&n.protocol!=="file:")throw new TypeError("Must be a file URL.");const t=await i("plugin:fs|create",{path:n instanceof URL?n.toString():n,options:e});return new d(t)}async function g(n,e){if(n instanceof URL&&n.protocol!=="file:")throw new TypeError("Must be a file URL.");const t=await i("plugin:fs|open",{path:n instanceof URL?n.toString():n,options:e});return new d(t)}async function y(n,e,t){if(n instanceof URL&&n.protocol!=="file:"||e instanceof URL&&e.protocol!=="file:")throw new TypeError("Must be a file URL.");await i("plugin:fs|copy_file",{fromPath:n instanceof URL?n.toString():n,toPath:e instanceof URL?e.toString():e,options:t})}async function A(n,e){if(n instanceof URL&&n.protocol!=="file:")throw new TypeError("Must be a file URL.");await i("plugin:fs|mkdir",{path:n instanceof URL?n.toString():n,options:e})}async function T(n,e){if(n instanceof URL&&n.protocol!=="file:")throw new TypeError("Must be a file URL.");return await i("plugin:fs|read_dir",{path:n instanceof URL?n.toString():n,options:e})}async function S(n,e){if(n instanceof URL&&n.protocol!=="file:")throw new TypeError("Must be a file URL.");const t=await i("plugin:fs|read_file",{path:n instanceof URL?n.toString():n,options:e});return t instanceof ArrayBuffer?new Uint8Array(t):Uint8Array.from(t)}async function E(n,e){if(n instanceof URL&&n.protocol!=="file:")throw new TypeError("Must be a file URL.");const t=await i("plugin:fs|read_text_file",{path:n instanceof URL?n.toString():n,options:e}),o=t instanceof ArrayBuffer?t:Uint8Array.from(t);return new TextDecoder().decode(o)}async function x(n,e){if(n instanceof URL&&n.protocol!=="file:")throw new TypeError("Must be a file URL.");const t=n instanceof URL?n.toString():n;return await Promise.resolve({path:t,rid:null,async next(){this.rid===null&&(this.rid=await i("plugin:fs|read_text_file_lines",{path:t,options:e}));const o=await i("plugin:fs|read_text_file_lines_next",{rid:this.rid}),r=o instanceof ArrayBuffer?new Uint8Array(o):Uint8Array.from(o),s=r[r.byteLength-1]===1;return s?(this.rid=null,{value:null,done:s}):{value:new TextDecoder().decode(r.slice(0,r.byteLength-1)),done:s}},[Symbol.asyncIterator](){return this}})}async function v(n,e){if(n instanceof URL&&n.protocol!=="file:")throw new TypeError("Must be a file URL.");await i("plugin:fs|remove",{path:n instanceof URL?n.toString():n,options:e})}async function C(n,e,t){if(n instanceof URL&&n.protocol!=="file:"||e instanceof URL&&e.protocol!=="file:")throw new TypeError("Must be a file URL.");await i("plugin:fs|rename",{oldPath:n instanceof URL?n.toString():n,newPath:e instanceof URL?e.toString():e,options:t})}async function _(n,e){const t=await i("plugin:fs|stat",{path:n instanceof URL?n.toString():n,options:e});return l(t)}async function M(n,e){const t=await i("plugin:fs|lstat",{path:n instanceof URL?n.toString():n,options:e});return l(t)}async function k(n,e,t){if(n instanceof URL&&n.protocol!=="file:")throw new TypeError("Must be a file URL.");await i("plugin:fs|truncate",{path:n instanceof URL?n.toString():n,len:e,options:t})}async function F(n,e,t){if(n instanceof URL&&n.protocol!=="file:")throw new TypeError("Must be a file URL.");if(e instanceof ReadableStream){const o=await g(n,{read:!1,create:!0,write:!0,...t}),r=e.getReader();try{for(;;){const{done:s,value:a}=await r.read();if(s)break;await o.write(a)}}finally{r.releaseLock(),await o.close()}}else await i("plugin:fs|write_file",e,{headers:{path:encodeURIComponent(n instanceof URL?n.toString():n),options:JSON.stringify(t)}})}async function z(n,e,t){if(n instanceof URL&&n.protocol!=="file:")throw new TypeError("Must be a file URL.");const o=new TextEncoder;await i("plugin:fs|write_text_file",o.encode(e),{headers:{path:encodeURIComponent(n instanceof URL?n.toString():n),options:JSON.stringify(t)}})}async function I(n,e){if(n instanceof URL&&n.protocol!=="file:")throw new TypeError("Must be a file URL.");return await i("plugin:fs|exists",{path:n instanceof URL?n.toString():n,options:e})}class p extends w{}async function L(n,e,t){const o=Array.isArray(n)?n:[n];for(const f of o)if(f instanceof URL&&f.protocol!=="file:")throw new TypeError("Must be a file URL.");const r=new R;r.onmessage=e;const s=await i("plugin:fs|watch",{paths:o.map(f=>f instanceof URL?f.toString():f),options:t,onEvent:r}),a=new p(s);return()=>{a.close()}}async function H(n,e,t){return await L(n,e,{delayMs:2e3,...t})}async function J(n,e,t){return await L(n,e,{...t,delayMs:void 0})}async function N(n){if(n instanceof URL&&n.protocol!=="file:")throw new TypeError("Must be a file URL.");return await i("plugin:fs|size",{path:n instanceof URL?n.toString():n})}export{c as BaseDirectory,d as FileHandle,u as SeekMode,y as copyFile,b as create,I as exists,M as lstat,A as mkdir,g as open,T as readDir,S as readFile,E as readTextFile,x as readTextFileLines,v as remove,C as rename,N as size,_ as stat,k as truncate,H as watch,J as watchImmediate,F as writeFile,z as writeTextFile};
